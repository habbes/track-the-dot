<style>
/* VISUALIZATION CSS */
.rest {
    fill: #c24445;
}
.target {
    fill: #fff;
}
.dot.youth {
    fill: #c24445;
}
.dot.male {
    fill: #da8e8f;
}
.dot.female {
    fill: #f3dada;
}
</style>
<div id="pie"></div>
<script src="d3/d3.js"></script>
<script>
var categories = ['youth', 'male', 'female'];
var data = [
    {
        town: 'Molo',
        unemployed: 35.5,
        youth: 40.3,
        male: 33.9,
        female: 25.8
    },
    {
        town: 'Naruko Kaptenbwo',
        unemployed: 23.8,
        youth: 40.3,
        male: 33.9,
        female: 25.8
    }
];
</script>
<script>

/**
 * splits town data into two
 * sections from which pie data
 * can be generated
 * @param {object} data
 * @return {array}
 */
function getTownData (data) {
    var rest = {
        key: 'rest',
        value: 100 - data.unemployed,
    };
    var target = {
        key: 'target',
        value: data.unemployed
    };
    categories.forEach(function (cat) {
        target[cat] = data[cat];
    });
    return [rest, target];
}

/**
 * converts a data array into an array
 * of pie data with computed startAngle, endAngle
 * and other properties used to create arcs
 * @param {array} data
 * @return {array}
 */
 var getPieData = d3.pie()
    .sort(function (a, b) { return b.value - a.value})
    .value(function (d) { return d.value });

/**
 * generates an svg transform to translate and scale
 * a group to match a standard cartesian coordinate space
 * i.e. the origin is at the center, x increases going right
 * and y increases going down
 * @param {number} width
 * @param {number} height
 * @return {string} svg transform string
 */
function getStandardCartesianTransform (width, height) {
    return 'translate(' + (width/2) + ',' + (height/2) + ')'
    + ' scale(1,-1)';
}

/**
 * generates an svg transform to rotate a pie/circle
 * by the specified angle (in degrees) from the
 * x-axis (after a 90degree rotation)
 * @param {number} angle
 * @return {string} svg transform string
 */
function getPieRotationTransform (angle) {
    return ' rotate(' + (90 + angle) + ')';
}

/**
 * compute the angle by which the pie has to be rotated relative
 * to the x-axis so that the x-axis cuts through the middle of
 * the target (open) sector
 * @param {array} pieData
 * @return {number} the angle for rotation
 */
function getPieRotationAngle (pieData) {
    var target = pieData.find(function (d) { return d.data.key === 'target'; });
    var total = d3.sum(pieData, function (d) { return d.value; });
    return 180 * target.value / total;
}

/**
 * returns a function with generates coordinates
 * for dots that are constrained within the open sector
 * of the pie
 * @param {number} radius the radius of the pie
 * @param {number} startAngle the start angle of the open sector in radians
 * @param {number} endAngle the end angle of the open sector in radians
 * @return {function} a function that, when called, returns an object
 * {x, y} where x and y are coordinates for a random point within the
 * specified open sector
 */
function sectorCoordGenerator (radius, startAngle, endAngle) {
    var angle = (endAngle  - startAngle) / 2;
    // get the min and max y values for coordinates in
    // this sector
    var maxY = radius * Math.sin(angle);
    var minY = -maxY;
    var getRandomY = d3.randomUniform(minY, maxY);
    var getRandomXForY = function (y) {
        // get the min and max x values for the given y
        // value in this sector
        var minX = Math.abs(y) / Math.tan(angle);
        var maxX = Math.sqrt(radius*radius - y*y);
        return d3.randomUniform(minX, maxX)();
    }
    return function () {
        var y = getRandomY();
        var x = getRandomXForY(y);
        return {
            x: x,
            y: y
        };
    };
}

/**
 * generate dots representing the people in the target
 * sector of a particular town
 * @param {object} townData
 * @param {function} coordsGenerator function used to generate
 * coords for dots
 * @return {array}
 */
function generateDotsForTown (townData, coordsGenerator) {
    var dots = categories.reduce(function(dots, cat) {
        var categoryDots = generateDotsForCategory(townData, cat, coordsGenerator);
        return d3.merge([dots, categoryDots]);
    }, []);
    return d3.shuffle(dots);
}

/**
 * generate dots representing the people in a particular
 * category in the given town
 * @param {object} townData
 * @param {string} category
 * @param {function} coordsGenerator function used to generate coords
 * for the dots
 * @return {array}
 */
function generateDotsForCategory (townData, category, coordsGenerator) {
    var count = Math.round(townData[category]);
    return d3.range(count).map(function (i) {
        var coord = coordsGenerator();
        return {
            category: category,
            key: category + '_' +  i,
            size: count,
            cx: coord.x,
            cy: coord.y
        };
    });
}

/**
 * generate dots representing the target data
 * to be displayed inside the open sector of the
 * pie
 * @param {array} pieData
 * @return {array}
 */
function generateSectorDots (pieData, radius) {
    var target = pieData.find(function (d) { return d.data.key === 'target'});
    var getRandomCoords = sectorCoordGenerator(radius, target.startAngle, target.endAngle);
    return generateDotsForTown(target.data, getRandomCoords);
}
</script>
<script>
var width = 700;
var height = 300;
var mainRadius = Math.min(width, height) / 2;
</script>
<script>
var root = d3.select("#pie");
var svg = root.append('svg')
    .attr('width', width)
    .attr('height', height);

/**
 * top-level group, wraps children in a cartesian coord space
 * with the origin at the center, x increasing going right
 * and y increasing going up
 */
var g = svg.append('g')
    .attr('transform', getStandardCartesianTransform(width, height));

/**
 * group containing the pie chart
 * pie chart will be in its own group so that
 * its rotation does not affect the rest of the children
 */
var pieG = g.append('g');

/**
 * function used to generate arc paths for the
 * sectors
 */
var pathFn = d3.arc()
    .outerRadius(mainRadius)
    .innerRadius(0);

// used make the dots move about their positions (implement wobble effect)
var deltaScale = d3.scaleLinear()
    .domain([0, 1])
    .range([-1, 1]);
</script>
<script>
/**
 * renders the pie chart with the specified pie data
 * @param {array} pieData data that has been passed
 * through getPieData function
 */
function renderPie (pieData) {
    var angle = getPieRotationAngle(pieData);

    var arc = pieG.selectAll('.arc')
        .data(pieData, function (d) { return d.data.key; });
    arc.exit().remove();
    var newArc = arc.enter().append('path')
        // .attr('class', 'arc')
        .classed('arc', true)
        .classed('rest', function (d) {
            return d.data.key === 'rest';
        })
        .classed('target', function (d) {
            return d.data.key === 'target';
        });
    
    arc = arc.merge(newArc);
    arc
        .transition(1000)
        .attr('d', pathFn);
    
    pieG.transition()
    .duration(1000)
    .attr('transform', getPieRotationTransform(angle));
}

/**
 * render dots representing the target population
 * in the open sector of the pie chart
 * @param {array} dots dots generated for the open sector
 */
function renderDots (dots) {
    var circles = g.selectAll('.dot').data(dots, function (dot) { return dot.key; });
    circles.exit().remove();
    var newCircles = circles.enter().append('circle')
        .attr('class', 'dot')
        .attr('cx', 0)
        .attr('cy', 0);

    circles = circles.merge(newCircles);
    circles
        .classed('youth', function (d) {
            return d.category === 'youth';
        })
        .classed('male', function (d) {
            return d.category === 'male';
        })
        .classed('female', function (d) {
            return d.category === 'female';
        })
        .transition()
        .duration(1000)
        .attr('cx', function (d) {
            return d.cx;
        })
        .attr('cy', function (d) {
            return d.cy;
        })
        .attr('r', 4);
}

function makeWobblingDotsRenderer () {
    // wrap the function in a closure so
    // that the wobbleInterval handle is not
    // exposed in the global namespace

    // the handle for the wobble effect inverval
    var wobbleInterval;

    return function (pieData) {
        wobbleInterval && wobbleInterval.stop();
        var dots = generateSectorDots(pieData, mainRadius);
        renderDots(dots);
        
        // make the dots wobble around their positions
        wobbleInterval = d3.interval(function () {
            g.selectAll('circle.dot').data(dots, function(d) {return d.key})
                .transition()
                .ease(d3.easeLinear)
                .duration(500)
                .attr('cx', function (d) {
                    return d.cx + deltaScale(Math.random());
                })
                .attr('cy', function (d) {
                    return d.cy +  deltaScale(Math.random());
                })
        }, 500);
    }
}

var renderWobblingDots = makeWobblingDotsRenderer();
function renderPieAndDots (pieData) {
    renderPie(pieData);
    renderWobblingDots(pieData);
}

/**
 * render entire visualization
 * including legend
 * @param {array} data
 */
function renderViz (data, activeIndex) {
    var townData = data[activeIndex];
    var townRawPieData = getTownData(townData);
    var pieData = getPieData(townRawPieData);
    renderPieAndDots(pieData);
}
</script>
<script>
renderViz(data, 0);
</script>
<style>
/* vizualization css */
.dot {
    fill: red;
}
.dot.child {
    opacity: 0.5;
}

.dot.man {
    opacity: 0.75
}

.dot.woman {
    opacity: 0.25
}

.dot.youth {
    opacity: 1
}
</style>
<div id="controls">
</div>
<div id="viz"></div>
<script src="d3/d3.min.js"></script>
<script>
var illiteracyData = {
    'Naivasha': {
        town: 'Naivasha',
        child: 10,
        youth: 35,
        man: 30,
        woman: 25
    },
    'Molo': {
        town: 'Molo',
        child: 10,
        youth: 40,
        man: 20,
        woman: 30
    }
};

/**
 * generates an random array of individual data points based on the
 * the percentage counts of the different categories
 * in the specified town data
 * @param {object} data
 * @return {array}
 */
function generateDatapointsForTown (data) {
    var categories = ['child', 'youth', 'man', 'woman'];
    var datapoints = categories.reduce(function(points, cat) {
        var categoryPoints = generateDatapointsForCategory(data, cat);
        return d3.merge([points, categoryPoints]);
    }, []);
    return d3.shuffle(datapoints);
}

/**
 * generates an array of individual data points for
 * a given category based on its proportion in the
 * counts of a particular town
 * @param {object} data town data
 * @param {string} category
 * @return {array}
 */
function generateDatapointsForCategory (data, category) {
    var count = data[category];
    return d3.range(count).map(function (i) {
        return {
            category: category,
            key: category + '_' +  i,
            size: count,
            cx: Math.random(),
            cy: Math.random()
        }
    });
}

</script>
<script>
var width = 700;
var height = 300;
</script>
<script>
var root = d3.select("#viz");
var viz = root.append('svg')
    .style('display', 'block')
    .attr('width', width)
    .attr('height', height);
</script>
<script>
var rScale = d3.scaleLinear()
    .domain([0, 30])
    .range([0, 6]);
var xScale = d3.scaleLinear()
    .domain([0, 1])
    .range([30, width-30]);
var yScale = d3.scaleLinear()
    .range([30, height-30]);

// used make the dots move about their positions (implement wobble effect)
var deltaScale = d3.scaleLinear()
    .domain([0, 1])
    .range([-1, 1]);

/**
 * implodes all the dots currently visualized
 * into the center of the graph
 */
function implodeDots () {
    viz.selectAll('circle.dot')
        .transition()
        .duration(1000)
        .attr('cx', function (d) {
            return xScale(0.5)
        })
        .attr('cy', function (d) {
            return yScale(0.5)
        });
}

// the handle for the wobble effect inverval
var wobbleInterval;

/**
 * render dots vizualization
 * based on the specified data
 * @param {array} data array containing each data point/dot
 */
function renderData(data) {
    // clear wobble effect
    wobbleInterval && wobbleInterval.stop();

    // collapse current data set
    implodeDots();

    setTimeout(function () {
        var dots = viz.selectAll('circle.dot').data(data, function (d) {return d.key})

        dots.exit()
        .remove();

        // explode new dots from the center
        var newDots = dots.enter().append('circle')
        .classed('dot', true)
        .attr('cx', xScale(0.5))
        .attr('cy', yScale(0.5))
        .attr('r', rScale(0));

        dots = dots.merge(newDots);
        dots
        .classed('child', function (d) { return d.category === 'child'})
        .classed('youth', function (d) { return d.category === 'youth'})
        .classed('man', function (d) { return d.category === 'man'})
        .classed('woman', function (d) { return d.category === 'woman'})
        .transition()
        .duration(500)
        .attr('cx', function (d) {
            return xScale(d.cx);
        })
        .attr('cy', function (d) {
            return yScale(d.cy);
        })
        .attr('r', function (d) { return rScale(d.size) });

        // make the dots wobble around their positions
        wobbleInterval = d3.interval(function () {
            viz.selectAll('circle.dot').data(data, function(d) {return d.key})
                .transition()
                .ease(d3.easeLinear)
                .duration(500)
                .attr('cx', function (d) {
                    return xScale(d.cx ) + deltaScale(Math.random());
                })
                .attr('cy', function (d) {
                    return yScale(d.cy) +  deltaScale(Math.random());
                })
        }, 500);
    }, 1000);
    
}

</script>
<script>
d3.select("#controls")
    .append('select')
    .on('change', function (e) {
        var town = this.value;
        var townData = illiteracyData[town];
        var data = generateDatapointsForTown(townData);
        renderData(data);
    })
    .selectAll('option').data(Object.keys(illiteracyData))
    .enter()
    .append('option')
    .text(String)
    .attr('value', String);

</script>
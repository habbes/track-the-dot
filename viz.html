<style>
/* vizualization css */
.dot {
    fill: red;
}
.dot.child {
    opacity: 0.5;
}

.dot.man {
    opacity: 0.75
}

.dot.woman {
    opacity: 0.25
}

.dot.youth {
    opacity: 1
}
</style>
<style>
/* legend css */
.legend.town.active {
    font-weight: bold;
}
</style>
<div id="controls">
</div>
<div id="legend"></div>
<div id="viz"></div>
<script src="d3/d3.min.js"></script>
<script>
var illiteracyData = {
    'Naivasha': {
        town: 'Naivasha',
        child: 10,
        youth: 35,
        man: 30,
        woman: 25
    },
    'Molo': {
        town: 'Molo',
        child: 10,
        youth: 40,
        man: 20,
        woman: 30
    }
};

/**
 * generates an random array of individual data points based on the
 * the percentage counts of the different categories
 * in the specified town data
 * @param {object} data
 * @return {array}
 */
function generateDatapointsForTown (data) {
    var categories = ['child', 'youth', 'man', 'woman'];
    var datapoints = categories.reduce(function(points, cat) {
        var categoryPoints = generateDatapointsForCategory(data, cat);
        return d3.merge([points, categoryPoints]);
    }, []);
    return d3.shuffle(datapoints);
}

/**
 * generates an array of individual data points for
 * a given category based on its proportion in the
 * counts of a particular town
 * @param {object} data town data
 * @param {string} category
 * @return {array}
 */
function generateDatapointsForCategory (data, category) {
    var count = data[category];
    return d3.range(count).map(function (i) {
        return {
            category: category,
            key: category + '_' +  i,
            size: count,
            cx: Math.random(),
            cy: Math.random()
        }
    });
}

</script>

<script>
/** DOTS VIZUALIZATION **/
var width = 700;
var height = 300;
</script>
<script>
var root = d3.select("#viz");
var viz = root.append('svg')
    .style('display', 'block')
    .attr('width', width)
    .attr('height', height);
</script>
<script>
var rScale = d3.scaleLinear()
    .domain([0, 30])
    .range([0, 6]);
var xScale = d3.scaleLinear()
    .domain([0, 1])
    .range([30, width-30]);
var yScale = d3.scaleLinear()
    .range([30, height-30]);

// used make the dots move about their positions (implement wobble effect)
var deltaScale = d3.scaleLinear()
    .domain([0, 1])
    .range([-1, 1]);

/**
 * implodes all the dots currently visualized
 * into the center of the graph
 */
function implodeDots () {
    viz.selectAll('circle.dot')
        .transition()
        .duration(1000)
        .attr('cx', function (d) {
            return xScale(0.5)
        })
        .attr('cy', function (d) {
            return yScale(0.5)
        });
}

// the handle for the wobble effect inverval
var wobbleInterval;

/**
 * render dots vizualization
 * based on the specified data
 * @param {array} data array containing each data point/dot
 */
function renderTownData(data) {
    // clear wobble effect
    wobbleInterval && wobbleInterval.stop();

    // collapse current data set
    // implodeDots();

    setTimeout(function () {
        var dots = viz.selectAll('circle.dot').data(data, function (d) {return d.key})

        dots.exit()
        .remove();

        // explode new dots from the center
        var newDots = dots.enter().append('circle')
        .classed('dot', true)
        .attr('cx', xScale(0.5))
        .attr('cy', yScale(0.5))
        .attr('r', rScale(0));

        dots = dots.merge(newDots);
        dots
        .classed('child', function (d) { return d.category === 'child'})
        .classed('youth', function (d) { return d.category === 'youth'})
        .classed('man', function (d) { return d.category === 'man'})
        .classed('woman', function (d) { return d.category === 'woman'})
        .transition()
        .duration(500)
        .attr('cx', function (d) {
            return xScale(d.cx);
        })
        .attr('cy', function (d) {
            return yScale(d.cy);
        })
        .attr('r', function (d) { return rScale(d.size) });

        // make the dots wobble around their positions
        wobbleInterval = d3.interval(function () {
            viz.selectAll('circle.dot').data(data, function(d) {return d.key})
                .transition()
                .ease(d3.easeLinear)
                .duration(500)
                .attr('cx', function (d) {
                    return xScale(d.cx ) + deltaScale(Math.random());
                })
                .attr('cy', function (d) {
                    return yScale(d.cy) +  deltaScale(Math.random());
                })
        }, 500);
    }, 1000);
    
}

</script>
<script>
/** LEGEND ANIMATION **/
d3.select("#controls")
    .append('select')
    .on('change', function (e) {
        var town = this.value;
        var townData = illiteracyData[town];
        var data = generateDatapointsForTown(townData);
        renderTownData(data);
    })
    .selectAll('option').data(Object.keys(illiteracyData))
    .enter()
    .append('option')
    .text(String)
    .attr('value', String);

// renderLegend(illiteracyData, 'Naivasha');

function renderLegend (data, activeTown) {
    data = d3.values(data);
    var towns = d3.select('#legend')
        .selectAll('.legend.town').data(data);
    towns.exit().remove();
    var newTowns = towns.enter()
        .append('div')
        .classed('legend', true)
        .classed('town', true);
    newTowns
        .append('span')
        .attr('class', 'title');
    towns = towns.merge(newTowns);
    towns
        .classed('active', function (data) {
            return data.town === activeTown
        })
        .select('span.title')
        .text(function (data) { return data.town });
}

</script>
<script>
/* VISUALIZATION LOOP */

vizLoop(illiteracyData, 5000);

/**
 * render vizualization, including legend,
 * setting the town at the specified index
 * as active
 * @param {object} array
 * @param {number} activeIndex
 */
function renderViz (data, activeIndex) {
    var townData = data[activeIndex];
    var town = townData.town;
    var dots = generateDatapointsForTown(townData);
    renderLegend(data, town);
    renderTownData(dots);
}

/**
 * render the vizualization in a loop,
 * changing the active town after the
 * specified interval
 * @param {object} data
 * @param {number} interval
 */
function vizLoop (data, interval) {
    data = d3.values(data);
    // show the viz the first time
    renderViz(data, 0);
    var index = 1;
    d3.interval(function () {
        renderViz(data, index);
        index = (index + 1) % data.length;
    }, interval);
}
</script>